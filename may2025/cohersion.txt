[] + [] â†’ "" (empty string)

[] + {} â†’ "[object Object]"

{} + [] â†’ 0 (block + array)

1 + '1' â†’ "11"

1 - '1' â†’ 0

'5' * '2' â†’ 10

'10' - true â†’ 9

'10' + true â†’ "10true"

null + 1 â†’ 1

undefined + 1 â†’ NaN

[] == false â†’ true

[] == [] â†’ false (ref compare)

[1,2] == '1,2' â†’ true (toString)

{ } == { } â†’ false

'' == 0 â†’ true

!!'false' == !!'true' â†’ true

false == '0' â†’ true

null == undefined â†’ true

null === undefined â†’ false

'' == false â†’ true

true + false â†’ 1

'1' + 1 + 9 â†’ "119"

{} + 1 â†’ 1 or NaN (context)

'123' + 123 â†’ "123123"

true + true â†’ 2

typeof 42 â†’ "number"

[] === false â†’ false

undefined + 1 â†’ NaN

1 + true + 1 â†’ 3

"5" + 2 + 3 â†’ "523"

+true â†’ 1

Boolean([]) â†’ true

Boolean("false") â†’ true

'b' + 'a' + + 'a' + 'a' â†’ "baNaNa" ğŸŒ

'4' * 2 â†’ 8

typeof null â†’ "object"

false == 0 â†’ true

'' == 0 â†’ true

0 === false â†’ false

0 == false â†’ true

ğŸ“Œ Important Topics You Mightâ€™ve Missed in Coercion:
Topic	Why Itâ€™s Important
Falsy/Truthy Values	false, 0, '', null, undefined, NaN are falsy â€” rest are truthy.
  
Unary + operator	Converts non-numbers to number. Ex: +'42' â†’ 42, +[] â†’ 0

isNaN() vs Number.isNaN()	isNaN('hello') is true, but Number.isNaN('hello') is false

Loose (==) vs Strict (===) Equality	Know which one does coercion (==)
  
Object to primitive coercion	Using valueOf() and toString() â€” objects become strings/numbers when forced
  
[] == ![] â†’ true	Mind-bending logic due to coercion

Template Literals & Coercion	${null}, ${undefined}, ${true} etc

Custom .toString() / .valueOf() methods	Useful when coercing class instances

ğŸ’¥ Bonus Interview-Level Questions (Add to Test):
What is the result of typeof NaN? â†’ "number"

Why does typeof null === 'object' return true? â†’ Legacy bug in JS

What is 0 + '0' - 0? â†’ 0

Why does '5' + + '5' return "55"? â†’ Unary + converts '5' to 5

What is false + true + "1"? â†’ "11"

1 < 2 < 3 vs 3 > 2 > 1 â€” explain difference? â†’ Due to coercion: left returns true, right returns false

'true' == true â†’ false (no numeric coercion here)

true == '1' â†’ true (both coerce to 1)

[] + 1 â†’ '1' (array becomes empty string, then string concat)

[null] + 1 â†’ 'null1'


console.log([null] == false); = true
console.log([undefined] == false) =true
console.log(false == 'false') = false
console.log("5" == 5) = true
console.log(parseInt('08')) = 8
console.log(' \t\r\n ' == 0) true
console.log(null == 0)  flse
console.log(Number([]))  0
console.log([] == ![]) true
console.log([1] + 1); 11
console.log([] + 1); 1
console.log([] + {}); [[object Object]]
console.log([] == []); false
console.log([]==={})
console.log([] + []); ""
console.log([] + {});[object Object]
console.log({} + []);[object Object]
console.log(null === undefined); false
console.log(null == undefined); true



[] == ![]..... Why is this true?

ğŸ” Step-by-step Breakdown:
ğŸ§© Step 1: Evaluate ![]
[] is truthy....So ![] is false 
[] == false
ğŸ§© Step 2: Now evaluate [] == false
Here comes type coercion with == (loose equality):
One is an object ([]), One is a boolean (false)
So JS converts both to primitives before comparing.
ğŸ§ª Coercion Rules in Action:
Step 2.1: Convert false to Number , false â†’ 0
Step 2.2: Convert [] to primitive , [].toString() â†’ "" (empty string)
"" â†’ when coerced to Number â†’ 0

So now youâ€™re comparing: 0 == 0 
âœ… Final Result: [] == ![]  â†’  [] == false  â†’  0 == 0  â†’  true


